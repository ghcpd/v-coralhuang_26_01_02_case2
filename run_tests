#!/usr/bin/env python3
"""One-command test runner (cross-platform).
Creates/reuses a .venv, installs pinned dependencies, and runs the full test suite.
Exits with a non-zero status if anything fails.
"""
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent
VENV_DIR = ROOT / ".venv"
REQ = ROOT / "requirements.txt"

PYTHON = sys.executable

def run(cmd, **kwargs):
    print(f"$ {' '.join(cmd)}")
    return subprocess.run(cmd, check=False, **kwargs)


def ensure_venv():
    if not VENV_DIR.exists():
        print("Creating virtual environment .venv...")
        subprocess.check_call([PYTHON, "-m", "venv", str(VENV_DIR)])


def venv_exe(name: str) -> str:
    if platform.system() == "Windows":
        return str(VENV_DIR / "Scripts" / f"{name}.exe")
    else:
        return str(VENV_DIR / "bin" / name)


def main():
    ensure_venv()
    pip = venv_exe("pip")
    py = venv_exe("python")

    # Try to upgrade pip/setuptools via the venv Python (more reliable on Win).
    # Non-fatal: some environments prevent self-upgrade — continue in that case.
    r = run([py, "-m", "pip", "install", "-U", "pip", "setuptools"])
    if r.returncode:
        print("warning: failed to upgrade pip/setuptools — continuing with existing pip", file=sys.stderr)

    # Install pinned requirements
    if not REQ.exists():
        print("requirements.txt not found", file=sys.stderr)
        sys.exit(1)
    r = run([pip, "install", "-r", str(REQ)])
    if r.returncode:
        sys.exit(r.returncode)

    # Run tests
    rc = run([py, "-m", "pytest", "-q"])  # -q for concise output
    sys.exit(rc.returncode)


if __name__ == "__main__":
    main()
